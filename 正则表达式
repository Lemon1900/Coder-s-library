regular expression
正则表达式由两种字符构成，特殊字符（special characters）成为元字符（metacharacters）,其他为文字(literal)或者普通文本字符(normal text characters)。
正则表达式的元字符提供了更强大的描述能力，它对应的是语法规则。

完整的正则表达式由小的构建模块单元(building block unit)组成，每个单独的构建模块都很简单，不过它能够有无数种组合，因此将它们结合起来实现特殊目标必须依靠经验。

元字符：
行的起始和结束：^代表以“^”后面跟着的第一个单元开始，$代表以“$”的前一个单元结束

结构体：
construct[...]
结构体的内部可以是具体的字符（字符组），也可以是字符的范围，用“-”连接表示范围，如1-9，a-z等
字符组内部只有表达连接范围的时候，“-”是元字符，其他时候都是普通字符，如[1-9_-!],其中，1和9中间的是元字符代表范围，其他字符全是普通字符

排除型字符：
结构体内以^表示不包括“^”后面一个单元的字符，“^”必须在方括号内部第一个位子，如[^1-6]代表排除1-6的范围

任意字符
.代表一个任意字符
比如：搜索03/19/76,03.19.76,03-19-76
可以用03[.-/]19[.-/]76,或者干脆尝试用03.19.76
前者表达的清楚，后者简单，到底如何用，这要看你对要检索的文本的了解程度和要表达的精确程度，在这之间做出平衡。

匹配任意字表达式
|或的意思，or

忽略大小写
可以用[Aa]
更简单的写法是在表达式前加“-i”
或者：/^[A-Z]/i.test("aa")，表示不区分大小写

转义：
使元字符失去特殊含义，变成普通符号
需要转义的符号前加/:如/<,/>,/!

限定范围()
括号限定表达式的范围，方便组合

可选项?
?后面的一个表达式或者字符，表示可以出现(也可没有)

重复出现
+和*
+表示之前紧邻的表达式内容出现一次或者多次（一次也匹配不成功，就出错）
*表示之前紧邻的表达式内容出现多次或者不出现(有没有都可以)

?+*称为量词

规定重现次数的范围
{min,max}

\s空白


/.../斜线用来表示表达式的边界，并不是表达式的一部分


[a-zA-Z]
字符组通常表示肯定断言，它必须匹配所给的字符，排除型字符组仍是必须匹配，不过是匹配未给出的字符组

\d  数字        等价于[0-9]
\D  非数字字符  等价于[^0-9]
\w  一般等价于  [a-zA-Z0-9]  (java.util.regex 中严格等价于[a-zA-Z0-9_],有的工具软件不匹配_,视情况而定)
\W  非单词字符  等价于[^\w]
\s  空白字符
\S  非空白字符  等价于[^\s]




一般来说，程序设计语言有三种方式处理正则表达式：集成式（integrated）,程序式(procedural)，面向对象式(object-oriented).
集成式就是正则表达式直接内建在语言中，Perl就是如此，其他两种方式中，正则表达式不属于语言的基本语法。

非集成式处理：
程序式处理和面向对象处理非常相似，在这两种方式下，正则不是由内建的操作符来提供，而是由普通函数或构造函数以及方法(面向对象)来提供。
这时函数把表达正则的表达式字符串作为正则表达式来处理。



引擎：NFA和DFA
NFA表达式主导-表达式匹配文本
特点：匹配过程反复尝试，各种回溯，标准量词优先匹配(*等)，
DFA文本主导-用文本匹配表达式
特点：寻找可能的最长匹配



使用技巧：
好的正则表达式必须在这些方面取得平衡：
1.只匹配期望的文本，排除不期望的文本；
2.必须易于控制和理解；
3.如果使用NFA引擎，必须保证效率(如果能匹配必须尽快返回匹配结果，如果不能匹配，应该在尽可能短的时间内报告匹配失败)









