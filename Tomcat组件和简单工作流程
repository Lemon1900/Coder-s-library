Tomcat是sun公司官方推荐的servlet和jsp容器.

tomcat目录
tomcat
|---bin Tomcat：存放启动和关闭tomcat脚本；
|---conf Tomcat：存放不同的配置文件（server.xml和web.xml）；
|---doc：存放Tomcat文档；
|---lib/japser/common：存放Tomcat运行需要的库文件（JARS）；
|---logs：存放Tomcat执行时的LOG文件；
|---src：存放Tomcat的源代码；
|---webapps：Tomcat的主要Web发布目录（包括应用程序示例）；
|---work：存放jsp编译后产生的class文件；

Tomcat配置文件：
conf文件夹可以看到Tomcat的配置文件：
server.xml: Tomcat的主配置文件，包含Service, Connector, Engine, Realm, Valve, Hosts主组件的相关配置信息；
web.xml：遵循Servlet规范标准的配置文件，用于配置servlet，并为所有的Web应用程序提供包括MIME映射等默认配置信息；
tomcat-user.xml：Realm认证时用到的相关角色、用户和密码等信息；Tomcat自带的manager默认情况下会用到此文件；在Tomcat中添加/删除用户，为用户指定角色等将通过编辑此文件实现；
catalina.policy：Java相关的安全策略配置文件，在系统资源级别上提供访问控制的能力；
catalina.properties：Tomcat内部package的定义及访问相关控制，也包括对通过类装载器装载的内容的控制；Tomcat在启动时会事先读取此文件的相关设置；
logging.properties: Tomcat6通过自己内部实现的JAVA日志记录器来记录操作相关的日志，此文件即为日志记录器相关的配置信息，可以用来定义日志记录的组件级别以及日志文件的存在位置等;；
context.xml：所有host的默认配置信息；


Tomcat架构及常用的组件：
1、Server组件
<Server port=”8005” shutdown=”SHUTDOWN”>
这会让Tomcat6启动一个server实例（即一个JVM），它监听在8005端口以接收shutdown命令，使用 telnet 连接8005 端口可以直接执行 SHUTDOWN 命令来关闭 Tomcat。
各Server的定义不能使用同一个端口，这意味着如果在同一个物理机上启动了多个Server实例，必须配置它们使用不同的端口。
这个端口的定义用于为管理员提供一个关闭此实例的便捷途径，因此，管理员可以直接telnet至此端口使用SHUTDOWN命令关闭此实例。
不过，基于安全角度的考虑，这通常不允许远程进行。

Server的相关属性：
className: 用于实现此Server容器的完全限定类的名称，默认为org.apache.catalina.core.StandardServer；
port: 接收shutdown指令的端口，默认仅允许通过本机访问，默认为8005；
shutdown：发往此Server用于实现关闭tomcat实例的命令字符串，默认为SHUTDOWN；

2、Service组件：
Service在Server下
Service主要用于关联一个引擎和与此引擎相关的连接器，每个连接器通过一个特定的端口和协议接收入站请求交将其转发至关联的引擎进行处理。
因此，Service要包含一个引擎、一个或多个连接器。

<Service name=”Catalina”>
这定义了一个名为Catalina的Service，此名字也会在产生相关的日志信息时记录在日志文件当中。
Service相关的属性：
className： 用于实现service的类名，一般都是org.apache.catalina.core.StandardService。
name：此服务的名称，默认为Catalina；

3、Connector组件：
进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类：
Tomcat作为应用程序服务器：请求来自于前端的web服务器，这可能是Apache, IIS, Nginx等；
Tomcat作为独立服务器：请求来自于web浏览器；
Tomcat应该考虑工作情形并为相应情形下的请求分别定义好需要的连接器才能正确接收来自于客户端的请求。一个引擎可以有一个或多个连接器，以适应多种请求方式。
定义连接器可以使用多种属性，有些属性也只适用于某特定的连接器类型。一般说来，常见于server.xml中的连接器类型通常有4种：
1) HTTP连接器 
2) SSL连接器 
3) AJP 1.3连接器 
4) proxy连接器
server.xml中定义的HTTP连接器：
<Connector port=”8080″ protocol=”HTTP/1.1″ maxThreads=”150″ connectionTimeout=”20000″ redirectPort=”8443″/>

定义连接器时可以配置的属性非常多，但通常定义HTTP连接器时必须定义的属性只有“port“，定义AJP连接器时必须定义的属性只有”protocol”，
因为默认的协议为HTTP。

以下为常用属性的说明：
1) address：指定连接器监听的地址，默认为所有地址，即0.0.0.0； 可以自己指定地，如
2) maxThreads：支持的最大并发连接数，默认为200；
3) port：监听的端口，默认为0；
4) protocol：连接器使用的协议，默认为HTTP/1.1，定义AJP协议时通常为AJP/1.3；
5) redirectPort：如果某连接器支持的协议是HTTP，当接收客户端发来的HTTPS请求时，则转发至此属性定义的端口；
6) connectionTimeout：等待客户端发送请求的超时时间，单位为毫秒，默认为60000，即1分钟；
7) enableLookups：是否通过request.getRemoteHost()进行DNS查询以获取客户端的主机名；默认为true； 进行反解的，可以设置为false
8) acceptCount：设置等待队列的最大长度；通常在tomcat所有处理线程均处于繁忙状态时，新发来的请求将被放置于等待队列中；


4、Engine组件：
Engine是Servlet处理器的一个实例，即servlet引擎，默认为定义在server.xml中的Catalina。
Engine需要defaultHost属性来为其定义一个接收所有发往非明确定义虚拟主机的请求的host组件。如：
<Engine name=”Catalina” defaultHost=”localhost”>

常用的属性定义：
defaultHost：Tomcat支持基于FQDN的虚拟主机，这些虚拟主机可以通过在Engine容器中定义多个不同的Host组件来实现；
            但如果此引擎的连接器收到一个发往非非明确定义虚拟主机的请求时则需要将此请求发往一个默认的虚拟主机进行处理，
            因此，在Engine中定义的多个虚拟主机的主机名称中至少要有一个跟defaultHost定义的主机名称同名；
name：Engine组件的名称，用于日志和错误信息记录时区别不同的引擎；
Engine容器中可以包含Realm、Host、Listener和Valve子容器。

5、Host组件：
位于Engine容器中用于接收请求并进行相应处理的主机或虚拟主机，如前面示例中的定义：

<Host name=”localhost” appBase=”webapps” unpackWARs=”true” autoDeploy=”true” xmlValidation=”false” xmlNamespaceAware=”false”>
</Host>
常用属性说明：
1) appBase：此Host的webapps目录，即存放非归档的web应用程序的目录或归档后的WAR文件的目录路径；可以使用基于$CATALINA_HOME的相对路径；
2) autoDeploy：在Tomcat处于运行状态时放置于appBase目录中的应用程序文件是否自动进行deploy；默认为true；（自动部署）
3) unpackWars：在启用此webapps时是否对WAR格式的归档文件先进行展开；默认为true；

主机别名定义：
如果一个主机有两个或两个以上的主机名，额外的名称均可以以别名的形式进行定义，如下：
<Host name=”www.ttlsa.com” appBase=”webapps” unpackWARs=”true”>
<Alias>feiyu.com</Alias>
</Host>

6、Context组件：

Context在某些意义上类似于apache中的路径别名，一个Context定义用于标识tomcat实例中的一个Web应用程序；如下面的定义：

<!– Tomcat Root Context –>
<Context path=”” docBase=”/web/webapps”/>

<!– buzzin webapp –>
<Context path=”/bbs”
docBase=”/web/threads/bbs”
reloadable=”true”>
</Context>

<!– chat server –>
<Context path=”/chat” docBase=”/web/chat”/>

<!– darian web –>
<Context path=”/darian” docBase=”darian”/>

在Tomcat6中，每一个context定义也可以使用一个单独的XML文件进行，其文件的目录为$CATALINA_HOME/conf//。
可以用于Context中的XML元素有Loader，Manager，Realm，Resources和WatchedResource。
常用的属性定义有：
1) docBase：相应的Web应用程序的存放位置；也可以使用相对路径，起始路径为此Context所属Host中appBase定义的路径；
            切记，docBase的路径名不能与相应的Host中appBase中定义的路径名有包含关系，比如，如果appBase为deploy，而docBase绝不能为deploy-bbs类的名字；
2) path：相对于Web服务器根路径而言的URI；如果为空“”，则表示为此webapp的根路径；如果context定义在一个单独的xml文件中，此属性不需要定义，
        有可能是别名；
3) reloadable：是否允许重新加载此context相关的Web应用程序的类；默认为false；

7、Realm组件：
一个Realm表示一个安全上下文，它是一个授权访问某个给定Context的用户列表和某用户所允许切换的角色相关定义的列表。
因此，Realm就像是一个用户和组相关的数据库。定义Realm时惟一必须要提供的属性是classname，它是Realm的多个不同实现，
用于表示此Realm认证的用户及角色等认证信息的存放位置。

ASRealm：基于Java Authintication and Authorization Service实现用户认证；

JDBCRealm：通过JDBC访问某关系型数据库表实现用户认证；

JNDIRealm：基于JNDI使用目录服务实现认证信息的获取；

MemoryRealm：查找tomcat-user.xml文件实现用户信息的获取；

UserDatabaseRealm：基于UserDatabase文件(通常是tomcat-user.xml)实现用户认证，它实现是一个完全可更新和持久有效的Memory.

8、Valve组件：
Valve类似于过滤器，它可以工作于Engine和Host/Context之间、Host和Context之间以及Context和Web应用程序的某资源之间。
一个容器内可以建立多个Valve，而且Valve定义的次序也决定了它们生效的次序。Tomcat6中实现了多种不同的Valve：

AccessLogValve：访问日志Valve

ExtendedAccessValve：扩展功能的访问日志Valve

JDBCAccessLogValve：通过JDBC将访问日志信息发送到数据库中；

RequestDumperValve：请求转储Valve；

RemoteAddrValve：基于远程地址的访问控制；

RemoteHostValve：基于远程主机名称的访问控制；

SemaphoreValve：用于控制Tomcat主机上任何容器上的并发访问数量；

JvmRouteBinderValve：在配置多个Tomcat为以Apache通过mod_proxy或mod_jk作为前端的集群架构中，当期望停止某节点时，可以通过此Valve将用记请求定向至备用节点；使用此Valve，必须使JvmRouteSessionIDBinderListener；

ReplicationValve：专用于Tomcat集群架构中，可以在某个请求的session信息发生更改时触发session数据在各节点间进行复制；

SingleSignOn：将两个或多个需要对用户进行认证webapp在认证用户时连接在一起，即一次认证即可访问所有连接在一起的webapp；

ClusterSingleSingOn：对SingleSignOn的扩展，专用于Tomcat集群当中，需要结合ClusterSingleSignOnListener进行工作；



Tomcat请求过程：
Tomcat Server处理一个HTTP请求的过程：
1、用户点击网页内容，请求被发送到本机端口8080，被在那里监听的Coyote HTTP/1.1 Connector获得。 
2、Connector把该请求交给它所在的Service的Engine来处理，并等待Engine的回应。 
3、Engine获得请求localhost/test/index.jsp，匹配所有的虚拟主机Host。 
4、Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机），
  名为localhost的Host获得请求/test/index.jsp，匹配它所拥有的所有的Context。
  Host匹配到路径为/test的Context（如果匹配不到就把该请求交给路径名为“ ”的Context去处理）。 
5、path=“/test”的Context获得请求/index.jsp，在它的mapping table中寻找出对应的Servlet。Context匹配到URL PATTERN为*.jsp的Servlet,
   对应于JspServlet类。 
6、构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet（）或doPost（）.执行业务逻辑、数据存储等程序。 
7、Context把执行完之后的HttpServletResponse对象返回给Host。 
8、Host把HttpServletResponse对象返回给Engine。 
9、Engine把HttpServletResponse对象返回Connector。 
10、Connector把HttpServletResponse对象返回给客户Browser。



详细过程：
Tomcat 核心组件是：Connector 和 Container
一个 Container 可以选择对应多个 Connector。多个 Connector 和一个 Container 就形成了一个 Service.
有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人控制，那就非 Server 莫属了。
所以整个 Tomcat 的生命周期由 Server 控制。

一个 Service 可以设置多个 Connector，但是只能有一个 Container 容器
Service 接口的方法列表如下：
Interface：Serice
Method:getContainer()
       setContainer(Container)
       getInfo()
       getName()
       getName(String)
       getServer()
       getServer(Server)
       addConnector(Connector)
       findConnectors()
       removeConnector(Connector)
       initialize()
       
从 Service 接口中定义的方法中可以看出，它主要是为了关联 Connector 和 Container，同时会初始化它下面的其它组件，
注意接口中它并没有规定一定要控制它下面的组件的生命周期。所有组件的生命周期在一个 Lifecycle 的接口中控制，这里用到了一个重要的设计模式，
关于这个接口将在后面介绍。
Tomcat 中 Service 接口的标准实现类是 StandardService 它不仅实现了 Service 借口同时还实现了 Lifecycle 接口，
这样它就可以控制它下面的组件的生命周期了。StandardService 类结构图如下:
Class:StandardService
field:connectors:Connector[]
      container:Container
      debug:int
      info:String
      initialized:boolean
      name:String
      lifecycle:LifecycleSupport
      sm:StringManager
      server:Server
      started:boolean
      support:PropertyChangeSupport
method:getContainer()
       setContainer(Container)
       getDebug()
       setDebug(int)
       getInfo()
       getName()
       getName(String)
       getServer()
       setServer(Server)
       addConnector(Connector)
       addPropertyChangeListener(PropertyChangeListener)
       findConnectors()
       removeConnector(Connector)
       removePropertyChangeListener(PropertyChangeListener)
       toString()
       addLifecycleListener(LifecycleListener)
       findLifecycleListeners()
       removeLifecycleListener(LifecycleListener)
       start()
       stop()
       initialize()
       
可以看出除了 Service 接口的方法的实现以及控制组件生命周期的 Lifecycle 接口的实现，还有几个方法是用于在事件监听的方法的实现，
不仅是这个 Service 组件，Tomcat 中其它组件也同样有这几个方法，这也是一个典型的设计模式，将在后面介绍。

StandardService 中主要的几个方法实现的代码，下面是 setContainer 和 addConnector 方法的源码：

StandardService. SetContainer:
public void setContainer(Container container) {
    Container oldContainer = this.container;
    if ((oldContainer != null) && (oldContainer instanceof Engine))
        ((Engine) oldContainer).setService(null);
    this.container = container;
    if ((this.container != null) && (this.container instanceof Engine))
        ((Engine) this.container).setService(this);
    if (started && (this.container != null) && (this.container instanceof Lifecycle)) {
        try {
            ((Lifecycle) this.container).start();
        } catch (LifecycleException e) {
            ;
        }
    }
    synchronized (connectors) {
        for (int i = 0; i < connectors.length; i++)
            connectors[i].setContainer(this.container);
    }
    if (started && (oldContainer != null) && (oldContainer instanceof Lifecycle)) {
        try {
            ((Lifecycle) oldContainer).stop();
        } catch (LifecycleException e) {
            ;
        }
    }
    support.firePropertyChange("container", oldContainer, this.container);
}
       
这段代码很简单，其实就是先判断当前的这个 Service 有没有已经关联了 Container，如果已经关联了，那么去掉这个关联关系—— oldContainer.setService(null)。
如果这个 oldContainer 已经被启动了，结束它的生命周期。然后再替换新的关联、再初始化并开始这个新的 Container 的生命周期。
最后将这个过程通知感兴趣的事件监听程序。这里值得注意的地方就是，修改 Container 时要将新的 Container 关联到每个 Connector，
还好 Container 和 Connector 没有双向关联，不然这个关联关系将会很难维护。      
       
StandardService. addConnector:
public void addConnector(Connector connector) {
    synchronized (connectors) {
        connector.setContainer(this.container);
        connector.setService(this);
        Connector results[] = new Connector[connectors.length + 1];
        System.arraycopy(connectors, 0, results, 0, connectors.length);
        results[connectors.length] = connector;
        connectors = results;
        if (initialized) {
            try {
                connector.initialize();
            } catch (LifecycleException e) {
                e.printStackTrace(System.err);
            }
        }
        if (started && (connector instanceof Lifecycle)) {
            try {
                ((Lifecycle) connector).start();
            } catch (LifecycleException e) {
                ;
            }
        }
        support.firePropertyChange("connector", null, connector);
    }
}

这个方法也很简单，首先是设置关联关系，然后是初始化工作，开始新的生命周期。这里值得一提的是，注意 Connector 用的是数组而不是 List 集合，
这个从性能角度考虑可以理解，有趣的是这里用了数组但是并没有向我们平常那样，一开始就分配一个固定大小的数组，
它这里的实现机制是：重新创建一个当前大小的数组对象，然后将原来的数组对象 copy 到新的数组中，这种方式实现了类似的动态数组的功能，
这种实现方式，值得我们以后拿来借鉴。

Server 要完成的任务很简单，就是要能够提供一个接口让其它程序能够访问到这个 Service 集合、同时要维护它所包含的所有 Service 的生命周期，
包括如何初始化、如何结束服务、如何找到别人要访问的 Service.
Server 的类结构:
String getInfo()
NamingResource getGlobalNameingResource()
void setGlobalNamingResource(NamingResource globalNamingResource)
int getPort()
void setPort(int port)
String getShutdown()
void setShutdown(String shutdown)
void addService(Service service)
void await()
Service findService(String name)
Service[] findServices()
void removeService(Service service)
void initialize()

它的标准实现类 StandardServer 实现了上面这些方法，同时也实现了 Lifecycle、MbeanRegistration 两个接口的所有方法，
下面主要看一下 StandardServer 重要的一个方法 addService 的实现：
StandardServer.addService:
public void addService(Service service) {
    service.setServer(this);
    synchronized (services) {
        Service results[] = new Service[services.length + 1];
        System.arraycopy(services, 0, results, 0, services.length);
        results[services.length] = service;
        services = results;
        if (initialized) {
            try {
                service.initialize();
            } catch (LifecycleException e) {
                e.printStackTrace(System.err);
            }
        }
        if (started && (service instanceof Lifecycle)) {
            try {
                ((Lifecycle) service).start();
            } catch (LifecycleException e) {
                ;
            }
        }
        support.firePropertyChange("service", null, service);
    }
}
 Service 和 Server 是相互关联的，Server 也是和 Service 管理 Connector 一样管理它，
 也是将 Service 放在一个数组中，后面部分的代码也是管理这个新加进来的 Service 的生命周期。

组件的生命线“Lifecycle”:
Tomcat 中组件的生命周期是通过 Lifecycle 接口来控制的，组件只要继承这个接口并实现其中的方法就可以统一被拥有它的组件控制了，
这样一层一层的直到一个最高级的组件就可以控制 Tomcat 中所有组件的生命周期，这个最高的组件就是 Server，而控制 Server 的是 Startup，也就是您启动和关闭 Tomcat

Lifecycle 接口的类结构:
InterFace:Lifecycle
Method:void addLifecyclelistener(LifecycleListener listener)
       Lifecyclelistener[] findLifecyclelisteners()
       void removeLifecyclelistener(LifecycleListener listener)
       void start()
       void stop()
       
除了控制生命周期的 Start 和 Stop 方法外还有一个监听机制，在生命周期开始和结束的时候做一些额外的操作。
这个机制在其它的框架中也被使用，如在 Spring 中。关于这个设计模式会在后面介绍。

Lifecycle 接口的方法的实现都在其它组件中，就像前面中说的，组件的生命周期由包含它的父组件控制，
所以它的 Start 方法自然就是调用它下面的组件的 Start 方法，Stop 方法也是一样。如在 Server 中 Start 方法就会调用 Service 组件的 Start 方法，
Server 的 Start 方法代码如下：
public void start() throws LifecycleException {
    if (started) {
        log.debug(sm.getString("standardServer.start.started"));
        return;
    }
    lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, null);
    lifecycle.fireLifecycleEvent(START_EVENT, null);
    started = true;
    synchronized (services) {
        for (int i = 0; i < services.length; i++) {
            if (services[i] instanceof Lifecycle)
                ((Lifecycle) services[i]).start();
        }
    }
    lifecycle.fireLifecycleEvent(AFTER_START_EVENT, null);
}

监听的代码会包围 Service 组件的启动过程，就是简单的循环启动所有 Service 组件的 Start 方法，
但是所有 Service 必须要实现 Lifecycle 接口，这样做会更加灵活。

public void stop() throws LifecycleException {
    if (!started)
        return;
    lifecycle.fireLifecycleEvent(BEFORE_STOP_EVENT, null);
    lifecycle.fireLifecycleEvent(STOP_EVENT, null);
    started = false;
    for (int i = 0; i < services.length; i++) {
        if (services[i] instanceof Lifecycle)
            ((Lifecycle) services[i]).stop();
    }
    lifecycle.fireLifecycleEvent(AFTER_STOP_EVENT, null);
}





