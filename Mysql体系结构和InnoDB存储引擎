在数据库领域中有两个词很容易混淆，它们就是"实例" (instance) 和"数据库"(database) 。作为常见的数据库术语，这两个词的定义如下。
数据库:
物理操作系统文件或其他形式文件类型的集合。在MySQL 中，数据库文件可以是frm 、myd 、myi 、ibd结尾的文件。当使用NDB 引擎肘，
数据库的文件可能不是操作系统上的文件，而是存放于内存之中的文件，但是定义仍然不变。
数据库实例:
由数据库后台进程/线程以及一个共享内存区组成。共享内存可以被运行的后台进程/线程所共享。需要牢记的是，数据库实例才是真正用来操作数据库文件的。

在MySQL中，实例和数据库的通常关系是一一对应，即一个实例对应一个数据库， 一个数据库对应一个实例。
但是，在集群情况下可能存在一个数据库可被多个实例使用的情况。

MySQL被设计为一个单进程多线程架构的数据库，这也就是说， MySQL数据库实例在系统上的表现就是一个进程。

当启动实例时， MySQL数据库会去读取配置文件，根据配置文件的参数来启动数据库实例。
在MySQL数据库中，可以没有配置文件，在这种情况下， MySQL会按照编译时的默认参数设置启动实例。
MySQL是按/etc/my.cnf--/etc/mysql/my.cnf--/usr/local/mysql/etc/my.cnf-/.my.cnf的顺序读取配置文件的
如果几个配置文件中都有同一个参数，MySQL以哪个配置文件为准?  MySQL会以读取到的最后一个配置文件中的参数为准。

从概念上来说，数据库是文件的集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合；
数据库实例是应用程序，是位于用户与操作系统之间的一层数据管理软件，用户对数据库数据的任何操作，包括数据库定义、数据查询、数据维护、数据库运行控制等，
都是在数据库实例下进行的，应用程序只有通过数据库实例才能和数据库打交道。
数据库是由一个个文件组成(一般来说都是二进制的文件)的，如果要对这些文件执行诸如SELECT 、INSERT 、UPDATE和DETELE之类的操作，
不能通过简单的操作文件来更改数据库的内容，需要通过数据库实例来完成对数据库的操作。

MySQL 由以下几部分组成:
连接池组件
管理服务和工具组件
SQL接口组件
查询分析器组件
优化器组件
缓冲(Cache) 组件
插件式存储引擎
物理文件

MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，
可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。
存储引擎是基于表的，而不是数据库。

由于MySQL是开源的，你可以根据MySQL预定义的存储引擎接口编写自己的存储引擎，或者是如果你对某种存储引擎不满意，可以通过修改源码来实现自己想耍的特性，
这就是开源的魅力所在。

由于MySQL的开源特性，存储引擎可以分为MySQL官方存储引擎和第三方存储引擎。有些第三方存储引擎很强大，如大名鼎鼎的InnoDB存储引擎(现已被Oracle收购) ，
其应用就极其广泛，甚至是MySQL数据库OLTP (Online Transaction Processing ，在线事务处理)应用中使用最广泛的存储引擎。

一、存储引擎

InnoDB存储引擎
InnoDB存储引擎支持事务，主要面向在线事务处理(OLTP) 方面的应用。其特点是行锁设计、支持外键，并支持类似于Oracle的非锁定读，
即默认情况下读取操作不会产生锁。MySQL 在Windows版本下的InnoDB是默认的存储引擎，同时InnoDB默认地被包含在所有的MySQL二进制发布版本中。

InnoDB存储引擎将数据放在一个逻辑的表空间中，这个表空间就像黑盒一样由InnoDB自身进行管理。从MySQL 4 .1 (包括4.1 )版本开始，
它可以将每个InnoDB存储引擎的表单独存放到一个独立的ibd文件中。与Oracle类似， InnoDB存储引擎同样可以使用裸设备(row dísk) 来建立其表空间。

InnoDB通过使用多版本并发控制(MVCC) 来获得高并发性，并且实现了SQL标准的4种隔离级别，默认为REPEATABLE级别。
同时使用一种被称为next-key locking的策略来避免幻读(phantom) 现象的产生。除此之外， InnoDB储存引擎还提供了插入缓冲(insertbuffer) 、
二次写(double write) 、自适应哈希索引(adaptive hash index) 、预读(read ahead) 等高性能和高可用的功能。

对于表中数据的存储， InnoDB存储引擎采用了聚集(clustered) 的方式，这种方式类似于Oracle的索引聚集表(index organized table , IOT)。
每张表的存储都按主键的顺序存放，如果没有显式地在表定义时指定主键， InnoDB存储引擎会为每一行生成一个6字节的ROWID ，并以此作为主键。

MylSAM存储引擎
MyISAM存储引擎是MySQL宫方提供的存储引擎。其特点是不支持事务、表锁和全文索引，对于一些OLAP (Online Analytical Processing ，在线分析处理)操作速度快。
除Windows版本外，是所有MySQL版本默认的存储引擎。

MyISAM存储引擎表由MYD和MYI组成， MYD用来存放数据文件， MYI用来存放索引文件。可以通过使用myisampack工具来进一步压缩数据文件，
因为myisampack工具使用赫失曼(Huffman) 编码静态算越来压缩数据，因此使用myisam pack工具压缩后的表是只读的，当然你也可以通过myisampack来解压数据文件。

在MySQL 5.0版本之前， MyISAM默认支持的表大小为40 ，如果需要支持大于40的MyISAM表时，则需要制定MAX_ROWS和AVO_ROW_LENOTH属性。
从MySQL 5.0版本开始， MyISAM默认支持256T的单表数据，这足够满足一般应用的需求。

NDB存储引擎
2003年， MySQL AB公司从Sony Ericsson公司收购了NDB 集群引擎。NDB存储引擎是一个集群存储引擎，类似于Oracle的RAC集群z 不过，
与Oracle RAC share everything结构不同的是，其结构是share nothing的集群架构.因此能提供更高级别的高可用性。
NDB的特点是数据全部放在内存中(从5.1 版本开始， 可以将非索引数据放在磁盘上) ，因此主键查找(primary key lookup) 的速度极快，
并且通过添加NDB数据存储节点(Data Node) 可以线性地提高数据库性能，是高可用、高性能的集群系统.关于NDB存储引擎，有一个问题值得注意，
那就是NDB存储引擎的连接操作(JOIN)是在MySQL数据库层完成的，而不是在存储引擎层完成的。这意味着，复杂的连接操作需要巨大的网络开销，
因此查询速度很慢。如果解决了这个问题， NDB存储引擎的市场应该是非常巨大的。

Memory存储引擎
Memory存储引擎(之前称为HEAP存储引擎)将表中的数据存放在内存中，如果数据库重启或发生崩槽，表中的数据都将消失。它非常适合用于存储临时数据的临时表，
以及数据仓库中的纬度表。它默认使用哈希索引，而不是我们熟悉的B+树索引。
虽然Memory存储引擎速度非常快，但在使用上还是有一定的限制。比如，其只支持表锁，并发性能较差，并且不支持TEXT和BLOB 列类型。最重要的是，
存储变长字段(varchar) 时是按照定常字段(char) 的方式进行的，因此会浪费内存(这个问题之前已经提到， eBay的Igor Chernyshev工程师已经给出了Patch方案).
此外有一点常被忽视的是，MySQL数据库使用Memory存储引擎作为临时表来存放查询的中间结果集(intermediate result) 。
如果中间结果集大于Memory存储引擎表的容量设置，又或者中间结果含有TEXT或BLOB类型字段，则MySQL数据库会把其转换到MyISAM存储引擎表而存放到磁盘。
之前提到My ISAM不缓存数据文件， 因此这时产生的临时表的性能对于查询会有损失。

其他存储引擎还有：
Archive存储引擎：只支持INSERT和SELECT操作，MySQL 5.1 开始支持索引。其使用zlib算法将数据行(row) 进行压缩后存储，压缩比率一般可达1 : 10 。
正如其名称所示，Archive存储引擎非常适合存储归档数据，如日志信息。Archive存储引擎·使用行锁来实现高并发的插入操作，但是本身并不是事物安全的存储引擎，
其设计目标主要是提供高速的插入和压缩功能。
Federated存储引擎：Federated存储引擎表并不存放数据，它只是指向一台远程MySQL数据库服务器上的表。这非常类似于SQL Server的链接服务器和Oracle的透明网关，
不同的是，当前Federated存储引擎只支持MySQL数据库表，不支持异构数据库表。
Maria存储引擎：Maria存储引擎是新开发的引擎，设计目标主要是用来取代原有的MyISAM存储引擎，从而成为MySQL的默认存储引擎，
开发者是MySQ L的创始人之一的Michael Widenius 。因此，它可以看作是MyISAM的后续版本。其特点是: 缓存数据和索引文件，行锁设计，提供MVCC功能，
支持事务和非事务安全的选项支持，以及更好的BLOB字符类型的处理性能。
还有很多其他的存储引擎，包括Merge 、CSV 、Sphìnx和Infobright ，它们都有各自适用的场合。

为什么MySQL不支持全文索引?不! MySQL支持， MyISAM 、Sphinx存储引擎支持全文索引。

MySQL快是因为不支持事务吗?错，MySQL MyISAM存储引擎不支持事务，但是InnoDB支持。快是相对于不同应用来说的，对于ETL这种操作， MyISAM当然有其优势。

当表的数据量大于1 000W时，MySQL的性能会急剧下降吗?不! MySQL是数据库，不是文件，随着数据行数的增加，性能当然会有所下降，但是这些下降不是线性的，
如果你选择了正确的存储引擎以及正确的配置， 再大的数据量MySQL也是能承受的。如官方手册上提及的， Mytrix和Inc.在InnoDB上存储了超过lTB 的数据， 
还有一些其他网站使用InnoDB存储引擎处理平均每秒800次插入/更新的操作。

存储引擎是MySQL体系结构的核心
MySQL存储引擎之间的不同之处，包括存储容量的限制、事务支持、锁的位度、MVCC支持、支持的索引、备份和复制等。每种存储引擎的实现都不相同。有些竟然不支持事务.
MySQL的设计者在开发时却认为不是所有的应用都需要事务，所以存在不支持事务的存储引擎.


连接MySQL
连接MySQL操作是连接进程和MySQL数据库实例进行通信，从开发的角度来说，本质上是进程通信。
TCP/IP套接字方式是MySQL在任何平台下都提供的连接方式，也是网络中使用得最多的一种方式。这种方式在TCP/IP连接上建立一个基于网络的连接请求，
一般情况下客户端在一台服务器上，而MySQL实例在另一台服务器上，这两台机器通过一个TCP/IP网络连接。
在通过TCP/IP连接到JMySQL实例时， MySQL会先检查一张权限视图，用来判断发起请求的客户端IP是否允许连接到JMySQL实例。

Unix域套接字
在Linux和Unix环境下，还可以使用Unix域套接字。Unix域套接字其实不是一个网络协议，所以只能在MySQL客户端和数据库实例在同一台服务器上的情况下使用。
你可以在配置文件中指定套接字文件的路径。

二、InnoDB存储引擎
InnoDB是事务安全的MySQL存储引擎，设计上采用了类似于Oracle的架构。一般而言，在OLTP的应用中， InnoDB应该作为核心应用表的首选存储引擎。
同时，也是因为lnnoDB的存在，才使得MySQL变得更有魅力。
OLTP：On-Line Transaction Processing联机事务处理过程。

lnnoDB 由Innobase Oy 公司开发。被包括在MySQL所有的二进制发行版本中，是Windows下默认的表存储引擎。
该存储引擎是第一个完整支持ACID事务的MySQL存储引擎(BDB是第一个支持事务的MySQL存储引擎，现在已经停止开发) ，行锁设计，支持MVCC ，
提供类似于Oracle风格的一致性非锁定读，支持外键，被设计用来最有效地利用内存和CPU 。InnoDB与OracJe很类似，也许这也是为什么OracJe要急于在MySQLAB之前收购该公司的原因。

ACID:指数据库事务正确执行的四个基本要素的缩写。包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。
一个支持事务（Transaction）的数据库，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易方的要求。


InnoDB体系架构:
InnoDB有多个内存块，你可以认为这些内存块组成了一个大的内存池，负责如下工作:
维护所有进程/线程需要访问的多个内部数据结构.
缓存磁盘上的数据，方便快速地读取，并且在对磁盘文件的数据进行修改之前在这里缓存.
重做日志(redo log ) 缓冲。

后台线程的主要作用是负责刷新内存池中的数据，保证缓冲地中的内存缓存的是最近的数据。此外，将已修改的数据文件刷新到磁盘文件，
同时保证在数据库发生异常情况下InnoDB能恢复到正常运行状态。

后台线程:
由于Oracle是多进程的架构(Windows下除外) ，因此可以通过一些很简单的命令来得知Oracle 当前运行的后台进程，如ipcs命令。
一般来说， Oracle的核心后台进程有CKPT 、DBWn 、LGWR 、ARCn 、PMON 、SMON等。

默认情况下， InnoDB存储引擎的后台线程有7个：4个io thread , 1 个master thread ,1个锁(lock) 监控线程， 1个错误监控线程。
io thread的数量由配置文件中的innodb_file_io_threads参数控制，默认为4.

mysq1> show engine innodb status\G;
*************************** 1. row ***************************
type:InnoDB
Name:
Status:
100719 21:34:03 1NNODB MON1TOR OUTPUT
Per second averages ca1cu1ated from the 1ast 50 seconds
F1LE 1/0
i/0 thread 0 state: waiting for i/o request (insert buffer thread)
i/0 thread 1 state: waiting for i/o request (log thread)
i/0 thread 2 state: waiting for i/o request (read thread)
i/0 thread 3 state: waiting for i/o request (write thread)
Pending norma1 aio reads: 0 , aio writes: 0,
ibuf aio reads: 0 , 10g i/o's: 0 , sync i/o's: 0
Pending f1ushes (fsync) 10g: 0; buffer poo1: 0
45 OS fi1e reads , 562 OS fi1e writes , 412 OS fsyncs
0 . 00 reads/s, 0 avg bytes/read, 0.00 writes/s , 0.00 fsyncs/s
END OF INNODB MONITOR OUTPUT

可以看到， 4个10线程分别是insert bu的r thread 、log thread 、read thread 、write thread。在Linux平台下， 10 thread的数量不能进行调整，
但是在Windows平台下可以通过参数innodb_file_io_threads来增大10 threado InnoDB Plugin版本开始增加了默认10 thread的数量，
默认的read thread 和write thread分别增大到了4个，并且不再使用innodb_file_io_threads参数， 
而是分别使用innodb_read_io_threads和innodb_write_io_threads参数.

内存：








