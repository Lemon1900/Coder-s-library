在数据库领域中有两个词很容易混淆，它们就是"实例" (instance) 和"数据库"(database) 。作为常见的数据库术语，这两个词的定义如下。
数据库:
物理操作系统文件或其他形式文件类型的集合。在MySQL 中，数据库文件可以是frm 、myd 、myi 、ibd结尾的文件。当使用NDB 引擎肘，
数据库的文件可能不是操作系统上的文件，而是存放于内存之中的文件，但是定义仍然不变。
数据库实例:
由数据库后台进程/线程以及一个共享内存区组成。共享内存可以被运行的后台进程/线程所共享。需要牢记的是，数据库实例才是真正用来操作数据库文件的。

在MySQL中，实例和数据库的通常关系是一一对应，即一个实例对应一个数据库， 一个数据库对应一个实例。
但是，在集群情况下可能存在一个数据库可被多个实例使用的情况。

MySQL被设计为一个单进程多线程架构的数据库，这也就是说， MySQL数据库实例在系统上的表现就是一个进程。

当启动实例时， MySQL数据库会去读取配置文件，根据配置文件的参数来启动数据库实例。
在MySQL数据库中，可以没有配置文件，在这种情况下， MySQL会按照编译时的默认参数设置启动实例。
MySQL是按/etc/my.cnf--/etc/mysql/my.cnf--/usr/local/mysql/etc/my.cnf-/.my.cnf的顺序读取配置文件的
如果几个配置文件中都有同一个参数，MySQL以哪个配置文件为准?  MySQL会以读取到的最后一个配置文件中的参数为准。

从概念上来说，数据库是文件的集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合；
数据库实例是应用程序，是位于用户与操作系统之间的一层数据管理软件，用户对数据库数据的任何操作，包括数据库定义、数据查询、数据维护、数据库运行控制等，
都是在数据库实例下进行的，应用程序只有通过数据库实例才能和数据库打交道。
数据库是由一个个文件组成(一般来说都是二进制的文件)的，如果要对这些文件执行诸如SELECT 、INSERT 、UPDATE和DETELE之类的操作，
不能通过简单的操作文件来更改数据库的内容，需要通过数据库实例来完成对数据库的操作。

MySQL 由以下几部分组成:
连接池组件
管理服务和工具组件
SQL接口组件
查询分析器组件
优化器组件
缓冲(Cache) 组件
插件式存储引擎
物理文件

MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，
可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。
存储引擎是基于表的，而不是数据库。

由于MySQL是开源的，你可以根据MySQL预定义的存储引擎接口编写自己的存储引擎，或者是如果你对某种存储引擎不满意，可以通过修改源码来实现自己想耍的特性，
这就是开源的魅力所在。

由于MySQL的开源特性，存储引擎可以分为MySQL官方存储引擎和第三方存储引擎。有些第三方存储引擎很强大，如大名鼎鼎的InnoDB存储引擎(现已被Oracle收购) ，
其应用就极其广泛，甚至是MySQL数据库OLTP (Online Transaction Processing ，在线事务处理)应用中使用最广泛的存储引擎。

一、存储引擎

InnoDB存储引擎
InnoDB存储引擎支持事务，主要面向在线事务处理(OLTP) 方面的应用。其特点是行锁设计、支持外键，并支持类似于Oracle的非锁定读，
即默认情况下读取操作不会产生锁。MySQL 在Windows版本下的InnoDB是默认的存储引擎，同时InnoDB默认地被包含在所有的MySQL二进制发布版本中。

InnoDB存储引擎将数据放在一个逻辑的表空间中，这个表空间就像黑盒一样由InnoDB自身进行管理。从MySQL 4 .1 (包括4.1 )版本开始，
它可以将每个InnoDB存储引擎的表单独存放到一个独立的ibd文件中。与Oracle类似， InnoDB存储引擎同样可以使用裸设备(row dísk) 来建立其表空间。

InnoDB通过使用多版本并发控制(MVCC) 来获得高并发性，并且实现了SQL标准的4种隔离级别，默认为REPEATABLE级别。
同时使用一种被称为next-key locking的策略来避免幻读(phantom) 现象的产生。除此之外， InnoDB储存引擎还提供了插入缓冲(insertbuffer) 、
二次写(double write) 、自适应哈希索引(adaptive hash index) 、预读(read ahead) 等高性能和高可用的功能。

对于表中数据的存储， InnoDB存储引擎采用了聚集(clustered) 的方式，这种方式类似于Oracle的索引聚集表(index organized table , IOT)。
每张表的存储都按主键的顺序存放，如果没有显式地在表定义时指定主键， InnoDB存储引擎会为每一行生成一个6字节的ROWID ，并以此作为主键。

MylSAM存储引擎
MyISAM存储引擎是MySQL宫方提供的存储引擎。其特点是不支持事务、表锁和全文索引，对于一些OLAP (Online Analytical Processing ，在线分析处理)操作速度快。
除Windows版本外，是所有MySQL版本默认的存储引擎。

MyISAM存储引擎表由MYD和MYI组成， MYD用来存放数据文件， MYI用来存放索引文件。可以通过使用myisampack工具来进一步压缩数据文件，
因为myisampack工具使用赫失曼(Huffman) 编码静态算越来压缩数据，因此使用myisam pack工具压缩后的表是只读的，当然你也可以通过myisampack来解压数据文件。

在MySQL 5.0版本之前， MyISAM默认支持的表大小为40 ，如果需要支持大于40的MyISAM表时，则需要制定MAX_ROWS和AVO_ROW_LENOTH属性。
从MySQL 5.0版本开始， MyISAM默认支持256T的单表数据，这足够满足一般应用的需求。

NDB存储引擎
2003年， MySQL AB公司从Sony Ericsson公司收购了NDB 集群引擎。NDB存储引擎是一个集群存储引擎，类似于Oracle的RAC集群z 不过，
与Oracle RAC share everything结构不同的是，其结构是share nothing的集群架构.因此能提供更高级别的高可用性。
NDB的特点是数据全部放在内存中(从5.1 版本开始， 可以将非索引数据放在磁盘上) ，因此主键查找(primary key lookup) 的速度极快，
并且通过添加NDB数据存储节点(Data Node) 可以线性地提高数据库性能，是高可用、高性能的集群系统.关于NDB存储引擎，有一个问题值得注意，
那就是NDB存储引擎的连接操作(JOIN)是在MySQL数据库层完成的，而不是在存储引擎层完成的。这意味着，复杂的连接操作需要巨大的网络开销，
因此查询速度很慢。如果解决了这个问题， NDB存储引擎的市场应该是非常巨大的。

Memory存储引擎
Memory存储引擎(之前称为HEAP存储引擎)将表中的数据存放在内存中，如果数据库重启或发生崩槽，表中的数据都将消失。它非常适合用于存储临时数据的临时表，
以及数据仓库中的纬度表。它默认使用哈希索引，而不是我们熟悉的B+树索引。
虽然Memory存储引擎速度非常快，但在使用上还是有一定的限制。比如，其只支持表锁，并发性能较差，并且不支持TEXT和BLOB 列类型。最重要的是，
存储变长字段(varchar) 时是按照定常字段(char) 的方式进行的，因此会浪费内存(这个问题之前已经提到， eBay的Igor Chernyshev工程师已经给出了Patch方案).
此外有一点常被忽视的是，MySQL数据库使用Memory存储引擎作为临时表来存放查询的中间结果集(intermediate result) 。
如果中间结果集大于Memory存储引擎表的容量设置，又或者中间结果含有TEXT或BLOB类型字段，则MySQL数据库会把其转换到MyISAM存储引擎表而存放到磁盘。
之前提到My ISAM不缓存数据文件， 因此这时产生的临时表的性能对于查询会有损失。

其他存储引擎还有：
Archive存储引擎：只支持INSERT和SELECT操作，MySQL 5.1 开始支持索引。其使用zlib算法将数据行(row) 进行压缩后存储，压缩比率一般可达1 : 10 。
正如其名称所示，Archive存储引擎非常适合存储归档数据，如日志信息。Archive存储引擎·使用行锁来实现高并发的插入操作，但是本身并不是事物安全的存储引擎，
其设计目标主要是提供高速的插入和压缩功能。
Federated存储引擎：Federated存储引擎表并不存放数据，它只是指向一台远程MySQL数据库服务器上的表。这非常类似于SQL Server的链接服务器和Oracle的透明网关，
不同的是，当前Federated存储引擎只支持MySQL数据库表，不支持异构数据库表。
Maria存储引擎：Maria存储引擎是新开发的引擎，设计目标主要是用来取代原有的MyISAM存储引擎，从而成为MySQL的默认存储引擎，
开发者是MySQ L的创始人之一的Michael Widenius 。因此，它可以看作是MyISAM的后续版本。其特点是: 缓存数据和索引文件，行锁设计，提供MVCC功能，
支持事务和非事务安全的选项支持，以及更好的BLOB字符类型的处理性能。
还有很多其他的存储引擎，包括Merge 、CSV 、Sphìnx和Infobright ，它们都有各自适用的场合。

为什么MySQL不支持全文索引?不! MySQL支持， MyISAM 、Sphinx存储引擎支持全文索引。

MySQL快是因为不支持事务吗?错，MySQL MyISAM存储引擎不支持事务，但是InnoDB支持。快是相对于不同应用来说的，对于ETL这种操作， MyISAM当然有其优势。

当表的数据量大于1 000W时，MySQL的性能会急剧下降吗?不! MySQL是数据库，不是文件，随着数据行数的增加，性能当然会有所下降，但是这些下降不是线性的，
如果你选择了正确的存储引擎以及正确的配置， 再大的数据量MySQL也是能承受的。如官方手册上提及的， Mytrix和Inc.在InnoDB上存储了超过lTB 的数据， 
还有一些其他网站使用InnoDB存储引擎处理平均每秒800次插入/更新的操作。

存储引擎是MySQL体系结构的核心
MySQL存储引擎之间的不同之处，包括存储容量的限制、事务支持、锁的位度、MVCC支持、支持的索引、备份和复制等。每种存储引擎的实现都不相同。有些竟然不支持事务.
MySQL的设计者在开发时却认为不是所有的应用都需要事务，所以存在不支持事务的存储引擎.


连接MySQL
连接MySQL操作是连接进程和MySQL数据库实例进行通信，从开发的角度来说，本质上是进程通信。
TCP/IP套接字方式是MySQL在任何平台下都提供的连接方式，也是网络中使用得最多的一种方式。这种方式在TCP/IP连接上建立一个基于网络的连接请求，
一般情况下客户端在一台服务器上，而MySQL实例在另一台服务器上，这两台机器通过一个TCP/IP网络连接。
在通过TCP/IP连接到JMySQL实例时， MySQL会先检查一张权限视图，用来判断发起请求的客户端IP是否允许连接到JMySQL实例。

Unix域套接字
在Linux和Unix环境下，还可以使用Unix域套接字。Unix域套接字其实不是一个网络协议，所以只能在MySQL客户端和数据库实例在同一台服务器上的情况下使用。
你可以在配置文件中指定套接字文件的路径。

二、InnoDB存储引擎
InnoDB是事务安全的MySQL存储引擎，设计上采用了类似于Oracle的架构。一般而言，在OLTP的应用中， InnoDB应该作为核心应用表的首选存储引擎。
同时，也是因为lnnoDB的存在，才使得MySQL变得更有魅力。
OLTP：On-Line Transaction Processing联机事务处理过程。

lnnoDB 由Innobase Oy 公司开发。被包括在MySQL所有的二进制发行版本中，是Windows下默认的表存储引擎。
该存储引擎是第一个完整支持ACID事务的MySQL存储引擎(BDB是第一个支持事务的MySQL存储引擎，现在已经停止开发) ，行锁设计，支持MVCC ，
提供类似于Oracle风格的一致性非锁定读，支持外键，被设计用来最有效地利用内存和CPU 。InnoDB与OracJe很类似，也许这也是为什么OracJe要急于在MySQLAB之前收购该公司的原因。

ACID:指数据库事务正确执行的四个基本要素的缩写。包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。
一个支持事务（Transaction）的数据库，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易方的要求。


InnoDB体系架构:
InnoDB有多个内存块，你可以认为这些内存块组成了一个大的内存池，负责如下工作:
维护所有进程/线程需要访问的多个内部数据结构.
缓存磁盘上的数据，方便快速地读取，并且在对磁盘文件的数据进行修改之前在这里缓存.
重做日志(redo log ) 缓冲。

后台线程的主要作用是负责刷新内存池中的数据，保证缓冲地中的内存缓存的是最近的数据。此外，将已修改的数据文件刷新到磁盘文件，
同时保证在数据库发生异常情况下InnoDB能恢复到正常运行状态。

后台线程:
由于Oracle是多进程的架构(Windows下除外) ，因此可以通过一些很简单的命令来得知Oracle 当前运行的后台进程，如ipcs命令。
一般来说， Oracle的核心后台进程有CKPT 、DBWn 、LGWR 、ARCn 、PMON 、SMON等。

默认情况下， InnoDB存储引擎的后台线程有7个：4个io thread , 1 个master thread ,1个锁(lock) 监控线程， 1个错误监控线程。
io thread的数量由配置文件中的innodb_file_io_threads参数控制，默认为4.

mysq1> show engine innodb status\G;
*************************** 1. row ***************************
type:InnoDB
Name:
Status:
100719 21:34:03 1NNODB MON1TOR OUTPUT
Per second averages ca1cu1ated from the 1ast 50 seconds
F1LE 1/0
i/0 thread 0 state: waiting for i/o request (insert buffer thread)
i/0 thread 1 state: waiting for i/o request (log thread)
i/0 thread 2 state: waiting for i/o request (read thread)
i/0 thread 3 state: waiting for i/o request (write thread)
Pending norma1 aio reads: 0 , aio writes: 0,
ibuf aio reads: 0 , 10g i/o's: 0 , sync i/o's: 0
Pending f1ushes (fsync) 10g: 0; buffer poo1: 0
45 OS fi1e reads , 562 OS fi1e writes , 412 OS fsyncs
0 . 00 reads/s, 0 avg bytes/read, 0.00 writes/s , 0.00 fsyncs/s
END OF INNODB MONITOR OUTPUT

可以看到， 4个10线程分别是insert buffer thread 、log thread 、read thread 、write thread。在Linux平台下， io thread 的数量不能进行调整，
但是在Windows平台下可以通过参数innodb_file_io_threads来增大io thread. InnoDB Plugin版本开始增加了默认io thread的数量，
默认的read thread 和write thread分别增大到了4个，并且不再使用innodb_file_io_threads参数， 
而是分别使用innodb_read_io_threads和innodb_write_io_threads参数.

内存：
InnoDB存储引擎内存由以下几个部分组成:缓冲地(buffer pool) 、重做日志缓冲地(redo log buffer) 以及额外的内存池(additional memory pool) ，
分别由配置文件中的参数innodb_buffer_pool_size和innodb_log_buffer_size的大小决定。

缓冲池是占最大块内存的部分，用来存放各种数据的缓存。因为InnoDB 的存储引擎的工作方式总是将数据库文件按页(每页16K) 读取到缓冲地，
然后按最近最少使用(LRU)的算法来保留在缓冲地中的缓存数据。如果数据库文件需要修改，总是首先修改在缓存池中的页(发生修改后，该页即为脏页) ，
然后再按照一定的频率将缓冲地的脏页刷新(flush) 到文件。
可以通过命令SHOW ENGINE INNODB STATUS来查看innodb_buffer_pool的具体使用情况：
mysql> show engine innodb status\G：
Status :
BUFFER POOL AND MEMORY
Buffer pool size 65536
Free buffers 51225
Database pages 12986
Modified db pages 8

在BUFFER POOL AND MEMORY里可以看到InnoDB存储引擎缓冲地的使用情况，buffer pool size表明了一共有多少个缓冲帧(buffer frame) ，
每个buffer frame为16K ，所以这里一共分配了65536*16/1024=lG 内存的缓冲池。Free buffers表示当前空闲的缓冲帧，Database pages表示已经使用的缓冲帧， 
Modified db pages表示脏页的数量。

缓冲池中缓存的数据页类型有:索引页、数据页、undo 页、插入缓冲(insert buffer) 、自适应哈希索引(adaptive hash index) 、
InnoDB存储的锁信息(lock info) 、数据字典信息(data dictionary) 等。不能简单地认为，缓冲地只是缓存索引页和数据页，它们只是占缓冲池很大的一部分而已。

日志缓冲将重做日志信息先放入这个缓冲区，然后按一定频导将其刷新到重做日志文件。该值一般不需要设置为很大，
因为一般情况下每一秒钟就会将重做日志缓冲刷新到日志文件，因此我们只需要保证每秒产生的事务量在这个缓冲大小之内即可。

额外的内存池通常被DBA忽略，认为该值并不是十分重要，但恰恰相反。在InnoDB存储引擎中，对内存的管理是通过一种称为内存堆(heap) 的方式进行的。
在对一些数据结构本身分配内存时，需要从额外的内存池中申请，当该区域的内存不够时，会从缓冲地中申请。
InnoDB实例会申请缓冲地(innodb_buffer_pool) 的空间，但是每个缓冲地中的帧缓冲(frame buffer) 还有对应的缓冲控制对象( buffercontrol block) ，
而且这些对象记录了诸如LRU 、锁、等待等方面的信息，而这个对象的内存需要从额外内存池中申请。因此，当你申请了很大的InnoDB缓冲地时，这个值也应该相应增加。

master thread
InnoDB存储引擎的主要工作都是在一个单独的后台线程master thread中完成的。
该线程的具体实现以及该线程可能存在的问题：
master thread的线程优先级别最高。其内部由几个循环(loop) 组成:主循环(loop) 、后台循环(backgroun d loop) 、刷新循环(flush loop) 、
暂停循环(suspend loop). master thread会根据数据库运行的状态在loop 、background loop 、flush loop和suspend loop中进行切换。

loop称为主循环，因为大多数的操作都在这个循环中，其中有两大部分操作:每秒钟的操作和每10秒的操作。伪代码如下:
void master_thread(){
loop,
for(int i = 0 ; i < 10; i++){
do thing once per second
sleep 1 second if necessary
do things once per ten seconds
goto

可以看到，loop循环通过thread sleep来实现，这意味着所谓的每秒一次或每10秒一次的操作是不精确的。
在负载很大的情况下可能会有延迟(delay) ，只能说大概在这个频率下。当然， I nnoDB源代码中还采用了其他的方法来尽量保证这个频率。

每秒一次的操作包括:
日志缓冲刷新到磁盘，即使这个事务还没有提交(总是)。
合并插入缓冲(可能)。
至多刷新100个InnoDB的缓冲池中的脏页到磁盘(可能)。
如果当前没有用户活动，切换到background loop (可能)。

即使某个事务还没有提交， InnoDB存储引擎仍然会每秒将重做日志缓冲中的内容刷新到重做日志文件。
这一点是必须知道的，这可以很好地解释为什么再大的事务commit的时间也是很快的。
合并插入缓冲(insert buffer) 并不是每秒都发生。InnoDB存储引擎会判断当前一秒内发生的io次数是否小于5次，
如果小于5 次， InnoDB认为当前的io压力很小，可以执行合并插入缓冲的操作。

同样，刷新100个脏页也不是每秒都在发生。
InnoDB存储引擎通过判断当前缓冲池中脏页的比例(buf_ get _ mod ified _ ratio _ pct) 是否超过了配置文件中i nnodb_max _dirty pages_pct 这个参数(默认为90 ，代表90%) ，
如果超过了这个阑值， InnoDB存储引擎认为需要做磁盘同步操作，将100个脏页写入磁盘。

伪代码可以进一步具体化：
void master_thread(){
goto 100p;
loop:
for(int i = 0; i<10; i++){
  thread_s1eep(1) // s1eep 1 second
  do 10g buffer f1ush to disk
  if (1ast_one_second_ios < 5 )
      do merge at most 5 insert buffer
  if ( buf_ get_modified_ ratio_pct > innodb_max_dirty_pages_pct )
      do buffer po01 f1ush 100 dirty page
  if ( no user activity )
      goto backgroud 100p
  }
  do things once per ten seconds
  background loop
    do something
    goto loop;
    
    
接着来看每10秒的操作，包括如下内容:
刷新100个脏页到磁盘(可能)。
合并至多5个插入缓冲(总是)。
将日志缓冲刷新到磁盘(总是)。
删除无用的Undo页(总是)。
刷新100个或者10个脏页到磁盘(总是)。
产生一个检查点(总是)。

在以上的过程中， lnnoDB存储引擎会先判断过去10秒之内磁盘的10操作是否小于200次。如果是， InnoDB存储引擎认为当前有足够的磁盘10操作能力，
因此将100个脏页刷新到磁盘。接着，Inno DB存储引擎会合并插入缓冲。不同于每l 秒操作时可能发生的合井插人缓冲操作，
这次的合并插入缓冲操作总会在这个阶段进行。之后， InnoDB存储引擎会再执行一次将日志缓冲刷新到磁盘的操作，这与每秒发生的操作是一样的。

接着lnnoDB存储引擎会执行一步full purge操作，即删除无用的Undo页。对表执行update 、delete这类操作时，原先的行被标记为删除，
但是因为一致性读(consistent read)的关系，需要保留这些行版本的信息。但是在full purge 过程中， 
InnoDB存储引擎会判断当前事务系统中已被删除的行是否可以删除，比如有时候可能还有查询操作需要读取之前版本的Undo信息，
如果可以， InnoDB 会立即将其删除。从源代码中可以发现， InnoDB存储引擎在操作full purge时，每次最多删除20个Undo页。
然后， InnoDB存储引擎会判断缓冲地中脏页的比例( bu f_get_modified_ratio_pct) ，如果有超过70%的脏页，则刷新100个脏页到磁盘；
如果脏页的比例小于70% ，则只需刷新10%的脏页到磁盘。

最后， InnoDB存储引擎会产生一个检查点(checkpoint) ， lnnoDB存储引擎的检查点也称为模糊检查点(fuzzy checkpoint)》
InnoDB存储引擎在checkpoint时并不会把所有缓冲池中的脏页都写入磁盘，因为这样可能会对性能产生影响，而只是将最老日志序列号(oldest LSN) 的页写入磁盘。

现在，我们可以完整地把主循环(main loop) 的伪代码写出来了，内容如下:
void master_ thread(){
goto loop;
loop:
for(int i = 0; i<10; i++){
    thread_s1eep(1) // s1eep 1 second
    do 1og buffer f1ush to disk
    if (last_one_ second_ios < 5 )
        do merge at most 5 insert buffer
    if ( buf_get_modified_ratio_pct > innodb_max_ dirty_ pages_pct )
        do buffer po01 flush 100 dirty page
    if ( no user activity )
        goto backgroud 100p
    if ( 1ast_ten_second_ios < 200 )
        do buffer po01 f1ush 100 dirty page
        do rnerge at rnost 5 insert buffer
        do log buffer f1ush to disk
      do fu11 purge
    if ( buf_get_modified_ratio_pct > 70革}
        do buffer poo1 f1ush 100 dirty page
    e1se
        buffer pool f1ush 10 dirty page
        do fuzzy checkpoint
    goto 100p
    background 1oop:
        do something
    goto loop;
}

接着来看background loop ，若当前没有用户活动(数据库空闲时)或者数据库关闭时，就会切换到这个循环。这个循环会执行以下操作:
删除无用的Undo页(总是)。
合并20个插入缓冲(总是)。
跳回到主循环(总是).

不断刷新100个页，直到符合条件(可能，跳转型Jflush ]OOp中完成).如果flush loop中也没有什么事情可以做了， InnoDB存储引擎会切换到suspend_loop,
将master thread挂起，等待事件的发生。若启用了InnoDB 存储引擎，却没有使用任何InnoDB存储引擎的表，那么master thread总是处于挂起状态。
  

最后，master thread完整的伪代码如下:
void master_thread(){
goto 1oop;
loop:
for(int i = 0; i<10; i++){
    thread_s1eep(1) // s1eep 1 second
    do 10g buffer f1ush to disk
    if ( 1ast_one_second_ ios < 5 )
        do merge at most 5 insert buffer
    if ( buf_get_modified_ratio_pct > innodb_max_dirty_pages_pct )
        do buffer po01 f1ush 100 dirty page
    if ( no user activity )
        goto backgroud loop
    if ( 1ast_ten_second_ ios < 200 )
        do buffer pool f1ush 100 dirty page
        do merge at most 5 insert buffer
        do log buffer f1ush to disk
        do full purge
    if ( buf_get_modified_ratio_pct > 70%}
        do buffer po01 f1ush 100 dirty page
    e1se
        buffer pool f1ush 10 dirty page
        do fuzzy checkpoint
    goto loop;
    background loop:
    do full purge
    do merge 20 insert buffer
    if not id1e:
        goto loop:
    e1se:
        goto f1ush loop
    f1ush loop:
    do buffer pool f1ush 100 dirty page
    if ( buf_get_modified_ratio_pct> innodb_max_dirty_pages_pct )
        goto f1ush loop
    goto suspend loop
    suspend loop:
    suspend_thread()
    waiting event
    goto loop;
}



master thread的潜在问题







