数据结构和算法能起到什么作用?
数据结构和算法是有关编程和数据存储的细致入微的基本规则。
正确选择数据结构会使程序的效率大大提高。算法是完成特定任务的过程。
数据结构是对在计算机内存中(有时在磁盘中)的数据的一种安排。数据结构包括数组、链表、枝、二叉树、哈希表等等。算法对这些结构中的数据进行各种处理。

并不是所有的存储结构都用来存储现实世界的数据。通常情况下，现实世界的数据或多或少会由程序的用户直接存取。但是有些数据存储结构并不打算让用户接触，
它们仅被程序本身所使用。程序员经常将诸如枝、队列和优先级队列等结构当作工具来简化另一些操作。

一般的数据结构包括数组、栈和队列、链表、树、哈希表、堆、图等

一、数组和排序
数组省略，操作有：初始化，插入，删除，排序，查找。
排序：
1.冒泡排序：
依次两两比较大小，按照规则进行换位，实现大小排序。
双层循环，第一层循环是为了驱动第二层循环完成每一遍后未完成排序的部分继续进行排序，第二层循环是为了驱动每一次两两大小比较进行。
public void  bubbleSort(){  
    int a[]={49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51};  
    int temp=0;  
    for(int i=0;i<a.length-1;i++){  
        for(int j=0;j<a.length-1-i;j++){  
            if(a[j]>a[j+1]){  
                temp=a[j];  
                a[j]=a[j+1];  
                a[j+1]=temp;  
            }  
        }  
    }  
    for(int i=0;i<a.length;i++){  
        System.out.println(a[i]);  
    }
}

冒泡排序的效率和稳定性：
数据项有N的话，排序进行：(N-1)+(N-2)+...+1=N(N-1)/2
所以冒泡排序时间级别是O(N's square).
交换级别：O(N's square).

2.选择排序：
每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕.

//选择排序
public void SelectionSort {
     int[] arr={1,3,2,45,65,33,12};
     System.out.println("交换之前：");
     for(int num:arr){
         System.out.print(num+" ");
     }        
     //选择排序的优化
     for(int i = 0; i < arr.length - 1; i++) {// 做第i趟排序
         int k = i;
         for(int j = k + 1; j < arr.length; j++){// 选最小的记录
             if(arr[j] < arr[k]){ 
                 k = j; //记下目前找到的最小值所在的位置
             }
         }
         //在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换
         if(i != k){  //交换a[i]和a[k]
             int temp = arr[i];
             arr[i] = arr[k];
             arr[k] = temp;
         }    
     }
     System.out.println();
     System.out.println("交换后：");
     for(int num:arr){
         System.out.print(num+" ");
     }
}
比较次数是N(N-1)/2，
所以选择排序时间级别是O(N's square).
当序列正序时，移动次数最少，为 0。当序列反序时，移动次数最多，为3N (N - 1) /  2。
交换级别：O(N's square).---交换比冒泡少


3.插入排序
假设第一个元素被放置在正确的位置上，这样仅需从下标1到n-1范围内对剩余元素进行排序;
每次外部遍历的任务是：通过扫描前面已排序的子列表，将位置i处的元素定位到从0到i的子列表之内的正确的位置上;将arr[i]复制为一个名为target的临时元素，
第二层，循环已经排好的列表，比较这个目标值target与已经排好的列表每个值，如果target小于被比较值就把被比较的值往后移动一位，一直到target不小于被比较的值，
此时，target的位置就是当前的列表循环到的下标的位置，放入。

public  void InsertSort(int[] arr){
    int i, j;
    int n = arr.Length;
    int target;
 
    //假定第一个元素被放到了正确的位置上
    //这样，仅需遍历下标1到 n-1
    for (i = 1; i < n; i++){
        j = i;
        target = arr[i];
        //往已排好的数组中插入
        while (j > 0 && target < arr[j - 1]){
            arr[j] = arr[j - 1];
            j--;
        }
        //不需要移动的位置就是target的位置
        arr[j] = target;
    }
}

空间复杂度O(1) 
时间复杂度O(n's square) 
最差情况：反序，需要移动n(n-1)/2个元素 
最好情况：正序，不需要移动元素
通常，插入排序呈现出二次排序算法中的最佳性能。
对于具有较少元素（如n<=15）的列表来说，二次算法十分有效


二、栈和队列
栈、队列和优先队列主要是作为程序员的工具，辅助构思算法的，而不是完全的数据存储工具。这些数据结构的生命周期通常比一般的数据库类型结构要短，在程序操作期间他们才会被创建，
通常用他们去执行特定任务，任务完成后就被销毁。

访问受限，数组可以通过下标或者迭代一一查出或者检索，但是栈和对列在特定时刻只有一个数据项可以被读取或者删除；更加抽象，他们的实现机制对用户来说是不可见的。

栈：栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。
向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，
使其相邻的元素成为新的栈顶元素。
栈可以用来在函数调用的时候存储断点，做递归时要用到栈，在计算机系统中，栈则是一个具有以上属性的动态内存区域。
大部分微处理器运用基于栈的体系结构，当调用一个方法时，把它的返回值和参数压入栈，当方法结束返回时压入栈的数据出栈。

pubic Class StackX{

    private int maxSize;
    private long[] stackArray;
    private int top;
    
    //constructor
    public StackX(int s){
        maxSize = s;                      //set array size
        stackArray = new long[maxSize];   //create array
        top = -1;                         //no items yet
    }
    
    //put item on top of stack
    public void push(long j){
        stackArray[++top] = j;            //increment top;insert item
    }    
    
    //tack item from top of stack
    public long pop(){
        return stackArray[top--];         //access item;decrement top
    }
    
    //peek top of stack
    public long peek(){
        return stackArray[top];
    }
    
    //true if stack is empty
    public boolean isEmpty(){
        return top ==-1;
    }
    
    //true if stack is full
    public boolean isFull(){
        return (top == maxSize-1);
    }
    
}

构造方法根据参数规定的容量创建一个新栈，栈的域包括表示最大容量的变量，数组本身以及变量top，top存储栈顶元素下标。（栈是数组实现，需要规定栈的大小，如果是链表实现，就不需要）


对列：
queue:队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，
和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。

在计算机操作系统或者网络里，有各种对列在安静的等待着工作。打印作业在打印对列中等待打印；当在键盘上敲击时，也有一个存储键入内容的对列；
利用对列保证了键入内容在处理时顺序不会发生变化。

public Class Queue{
    private int maxSize;
    private long[] queArray;
    private int front;
    private int rear;
    private int nItems;
    
    //constructor
    public Queue(int s){
        maxSize = s;
        queArray = new long[maxSize];
        front = 0;
        rear = -1;
        nItems = 0;
    }
    
    //put item at rear of queue
    public void insert(long j){
        if(rear == maxSize-1){     //deal with wrapround
            rear = -1
        }
        queArray[++rear] = j;      //increment rear and insert item
        nItems++;                 //one more item
    }
    
    //take item from front of queue
    public long remove(){
        long temp = queArray[front++];  //get value and increment front
        if(front==maxSize-1){           //deal with wrapround
            front = 0
        }
        nItem--;                        //one less item
        return temp;
      
     }
     
     //peek at front of queue
     public long peekFront(){
        return queArray[front];
     }
     
     //true if queue is empty
     public boolean isEmpty(){
        return nItem==0;
     }
     
     //true if queue is full
     public boolean ifFull(){
        return nItem == maxSize;
     }
     
     //number if item in queue
     public int size(){
        return nItem;
     }
}

有的对列没有nItem ,则相应的size,等各种方法的判断要复杂一点

双端对列：对列的每一端都可以插入或删除数据项，insertLeft,removeLeft,insertRight,removeRight;
如果禁止调用一端的进和出，就是一个栈；如果禁止调用一端的进和另一端的出，就是对列。

优先级对列：
优先级对列是比栈和对列更专用的数据结构，优先级对列有对头和对尾，但是数据项是按关键字的值有序，数据项插入的时候会按照顺序插入到合适的位置以确保顺序。
优先级对列经常用作程序员的编程工具，在计算机系统中也有很多应用，在抢先式多任务操作系统中，程序排在优先级对列中，这样优先级高的程序就会先得到时间片并运行。
优先级对列通常使用一种叫做堆的数据结构来实现，以下是一个普通的实现：

规则是小的优先：
public Class PriorityQ{
    private int maxSize;
    private long[] queArray;
    private int nItems;
    
    //constructor
    public PriorityQ(int s){
        maxSize = s;
        queArray = new long[maxSize];
        nItems = 0;
    }
    
    //insert item
    public void insert(long item){
        if(nItem==0){                               //if no item insert at 0
            queArray[nItem++] = item;
        }else{
            for(int j=nItem-1;j>=0;j--){            //loop start at end
                if(item>queArray[j]){
                    queArray[j+1] = queArray[j];    //if new item larger shift upward 
                }else{
                    break;                          //if smaller done shifting
                }
            }
            queArray[j+1] = item;                   //insert it
            nItem++;
        }
    }
    
    //remove min item
    public long remove(){
        return queArray[--nItem];
    }
    
    public long peekMin(){
        return queArray[nItem-1];
    }
    
     //true if queue is empty
     public boolean isEmpty(){
        return nItem==0;
     }
     
     //true if queue is full
     public boolean ifFull(){
        return nItem == maxSize;
     }
}


应用：解析算术表达式
步骤：
1.将算术表达式转换成后缀表达式
2.计算后缀表达式的值

日常算术表达式通常是将操作符放在两个操作数中间，这种写法叫做中缀表达式；操作符跟在两个操作数后面叫做后缀表达式也叫作波兰逆序表达式RPN
a+b---ab+
