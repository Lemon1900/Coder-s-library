数据结构和算法能起到什么作用?
数据结构和算法是有关编程和数据存储的细致入微的基本规则。
正确选择数据结构会使程序的效率大大提高。算法是完成特定任务的过程。
数据结构是对在计算机内存中(有时在磁盘中)的数据的一种安排。数据结构包括数组、链表、枝、二叉树、哈希表等等。算法对这些结构中的数据进行各种处理。

并不是所有的存储结构都用来存储现实世界的数据。通常情况下，现实世界的数据或多或少会由程序的用户直接存取。但是有些数据存储结构并不打算让用户接触，
它们仅被程序本身所使用。程序员经常将诸如枝、队列和优先级队列等结构当作工具来简化另一些操作。

一般的数据结构包括数组、栈和队列、链表、树、哈希表、堆、图等

一、数组和排序
数组省略，操作有：初始化，插入，删除，排序，查找。
排序：
1.冒泡排序：
依次两两比较大小，按照规则进行换位，实现大小排序。
双层循环，第一层循环是为了驱动第二层循环完成每一遍后未完成排序的部分继续进行排序，第二层循环是为了驱动每一次两两大小比较进行。
public void  bubbleSort(){  
    int a[]={49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51};  
    int temp=0;  
    for(int i=0;i<a.length-1;i++){  
        for(int j=0;j<a.length-1-i;j++){  
            if(a[j]>a[j+1]){  
                temp=a[j];  
                a[j]=a[j+1];  
                a[j+1]=temp;  
            }  
        }  
    }  
    for(int i=0;i<a.length;i++){  
        System.out.println(a[i]);  
    }
}

冒泡排序的效率和稳定性：
数据项有N的话，排序进行：(N-1)+(N-2)+...+1=N(N-1)/2
所以冒泡排序时间级别是O(N's square).
交换级别：O(N's square).

2.选择排序：
每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕.

//选择排序
public void SelectionSort {
     int[] arr={1,3,2,45,65,33,12};
     System.out.println("交换之前：");
     for(int num:arr){
         System.out.print(num+" ");
     }        
     //选择排序的优化
     for(int i = 0; i < arr.length - 1; i++) {// 做第i趟排序
         int k = i;
         for(int j = k + 1; j < arr.length; j++){// 选最小的记录
             if(arr[j] < arr[k]){ 
                 k = j; //记下目前找到的最小值所在的位置
             }
         }
         //在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换
         if(i != k){  //交换a[i]和a[k]
             int temp = arr[i];
             arr[i] = arr[k];
             arr[k] = temp;
         }    
     }
     System.out.println();
     System.out.println("交换后：");
     for(int num:arr){
         System.out.print(num+" ");
     }
}
比较次数是N(N-1)/2，
所以选择排序时间级别是O(N's square).
当序列正序时，移动次数最少，为 0。当序列反序时，移动次数最多，为3N (N - 1) /  2。
交换级别：O(N's square).---交换比冒泡少


3.插入排序
假设第一个元素被放置在正确的位置上，这样仅需从下标1到n-1范围内对剩余元素进行排序;
每次外部遍历的任务是：通过扫描前面已排序的子列表，将位置i处的元素定位到从0到i的子列表之内的正确的位置上;将arr[i]复制为一个名为target的临时元素，
第二层，循环已经排好的列表，比较这个目标值target与已经排好的列表每个值，如果target小于被比较值就把被比较的值往后移动一位，一直到target不小于被比较的值，
此时，target的位置就是当前的列表循环到的下标的位置，放入。

public  void InsertSort(int[] arr){
    int i, j;
    int n = arr.Length;
    int target;
 
    //假定第一个元素被放到了正确的位置上
    //这样，仅需遍历下标1到 n-1
    for (i = 1; i < n; i++){
        j = i;
        target = arr[i];
        //往已排好的数组中插入
        while (j > 0 && target < arr[j - 1]){
            arr[j] = arr[j - 1];
            j--;
        }
        //不需要移动的位置就是target的位置
        arr[j] = target;
    }
}

空间复杂度O(1) 
时间复杂度O(n's square) 
最差情况：反序，需要移动n(n-1)/2个元素 
最好情况：正序，不需要移动元素
通常，插入排序呈现出二次排序算法中的最佳性能。
对于具有较少元素（如n<=15）的列表来说，二次算法十分有效


二、栈和队列

