中介者模式(Mediator Pattern)：用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。

在中介者模式结构图中包含如下几个角色：
● Mediator（抽象中介者）：它定义一个接口，该接口用于与各同事对象之间进行通信。
● ConcreteMediator（具体中介者）：它是抽象中介者的子类，通过协调各个同事对象来实现协作行为，它维持了对各个同事对象的引用。
● Colleague（抽象同事类）：它定义各个同事类公有的方法，并声明了一些抽象方法来供子类实现，同时它维持了一个对抽象中介者类的引用，
  其子类可以通过该引用来与中介者通信。
● ConcreteColleague（具体同事类）：它是抽象同事类的子类；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，
  通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中声明的抽象方法。

中介者模式的核心在于中介者类的引入，在中介者模式中，中介者类承担了两方面的职责：
(1)中转作用（结构性）：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，可通过中介者来实现间接调用。
   该中转作用属于中介者在结构上的支持。
(2)协调作用（行为性）：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致的和中介者进行交互，而不需要指明中介者需要具体怎么做，
   中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。
   
在中介者模式中，典型的抽象中介者类代码如下所示：
abstract class Mediator {
	protected ArrayList<Colleague> colleagues; //用于存储同事对象

    //注册方法，用于增加同事对象
	public void register(Colleague colleague) {
		colleagues.add(colleague);
	}

	//声明抽象的业务方法
	public abstract void operation();
}

在抽象中介者中可以定义一个同事类的集合，用于存储同事对象并提供注册方法，同时声明了具体中介者类所具有的方法。
在具体中介者类中将实现这些抽象方法，典型的具体中介者类代码如下所示：
abstract class Colleague {
	protected Mediator mediator; //维持一个抽象中介者的引用
	
	public Colleague(Mediator mediator) {
		this.mediator=mediator;
	}
	
	public abstract void method1(); //声明自身方法，处理自己的行为
	
	//定义依赖方法，与中介者进行通信
	public void method2() {
		mediator.operation();
	}
}

在抽象同事类中声明了同事类的抽象方法，而在具体同事类中将实现这些方法，典型的具体同事类代码如下所示：
class ConcreteColleague extends Colleague {
	public ConcreteColleague(Mediator mediator) {
		super(mediator);
	}
	
    //实现自身方法
	public void method1() {
		......
	}
}

在具体同事类ConcreteColleague中实现了在抽象同事类中声明的方法，其中方法method1()是同事类的自身方法(Self-Method)，用于处理自己的行为，
而方法method2()是依赖方法(Depend-Method)，用于调用在中介者中定义的方法，依赖中介者来完成相应的行为，例如调用另一个同事类的相关方法。

eg:
软件公司欲开发一套CRM系统，其中包含一个客户信息管理模块,有一个客户管理窗口，包括客户列表(List)，客户选择组合框(ComboBox)，文本框类(TextBox)等
每一个界面组件都与多个其他组件之间产生相互关联和调用，每一个组件和其他组件之间都具有很强的关联，
使用中介者模式，
Component充当抽象同事类，Button、List、ComboBox和TextBox充当具体同事类，Mediator充当抽象中介者类，ConcreteMediator充当具体中介者类，
ConcreteMediator维持了对具体同事类的引用，为了简化ConcreteMediator类的代码，我们在其中只定义了一个Button对象和一个TextBox对象。
完整代码如下所示：
//抽象中介者
abstract class Mediator {
	public abstract void componentChanged(Component c);
}

//具体中介者
class ConcreteMediator extends Mediator {
	//维持对各个同事对象的引用
	public Button addButton;
	public List list;
	public TextBox userNameTextBox;
	public ComboBox cb;

    //封装同事对象之间的交互
	public void componentChanged(Component c) {
		//单击按钮
if(c == addButton) {
			System.out.println("--单击增加按钮--");
			list.update();
			cb.update();
			userNameTextBox.update();
		}
        //从列表框选择客户
		else if(c == list) {
			System.out.println("--从列表框选择客户--");
			cb.select();
			userNameTextBox.setText();
		}
        //从组合框选择客户
		else if(c == cb) {
			System.out.println("--从组合框选择客户--");
			cb.select();
			userNameTextBox.setText();
		}
	}
}

//抽象组件类：抽象同事类
abstract class Component {
	protected Mediator mediator;
	
	public void setMediator(Mediator mediator) {
		this.mediator = mediator;
	}

	//转发调用
	public void changed() {
		mediator.componentChanged(this);
	}
	
	public abstract void update();	
}

//按钮类：具体同事类
class Button extends Component {
	public void update() {
		//按钮不产生交互
	}
}

//列表框类：具体同事类
class List extends Component {
	public void update() {
		System.out.println("列表框增加一项：张无忌。");
	}
	
	public void select() {
		System.out.println("列表框选中项：小龙女。");
	}
}

//组合框类：具体同事类
class ComboBox extends Component {
	public void update() {
		System.out.println("组合框增加一项：张无忌。");
	}
	
	public void select() {
		System.out.println("组合框选中项：小龙女。");
	}
}

//文本框类：具体同事类
class TextBox extends Component {
	public void update() {
		System.out.println("客户信息增加成功后文本框清空。");
	}
	
	public void setText() {
		System.out.println("文本框显示：小龙女。");
	}
}

客户端测试代码：
class Client {
	public static void main(String args[]) {
        //定义中介者对象
		ConcreteMediator mediator;
		mediator = new ConcreteMediator();
		
        //定义同事对象
		Button addBT = new Button();
		List list = new List();
	    ComboBox cb = new ComboBox();
	    TextBox userNameTB = new TextBox();

		addBT.setMediator(mediator);
		list.setMediator(mediator);
		cb.setMediator(mediator);
		userNameTB.setMediator(mediator);

		mediator.addButton = addBT;
		mediator.list = list;
		mediator.cb = cb;
		mediator.userNameTextBox = userNameTB;
		
		addBT.changed();
		System.out.println("-----------------------------");
		list.changed();
	}
}

修改意见：要求在窗口的下端能够及时显示当前系统中客户信息的总数---增加一个文本标签(Label)来显示客户信息总数
当用户点击“增加”按钮或者“删除”按钮时，将改变文本标签的内容。

【解决方案一】增加一个界面组件类Label，修改原有的具体中介者类ConcreteMediator，增加一个对Label对象的引用，
然后修改componentChanged()方法中其他相关组件对象的业务处理代码，原有组件类无须任何修改，客户端代码也需针对新增组件Label进行适当修改。

【解决方案二】与方案一相同，首先增加一个Label类，但不修改原有具体中介者类ConcreteMediator的代码，
而是增加一个ConcreteMediator的子类SubConcreteMediator来实现对Label对象的引用，然后在新增的中介者类SubConcreteMediator中通过
覆盖componentChanged()方法来实现所有组件（包括新增Label组件）之间的交互，同样，原有组件类无须做任何修改，客户端代码需少许修改。
由于【解决方案二】无须修改ConcreteMediator类，更符合“开闭原则”，因此我们选择该解决方案来对新增Label类进行处理
 
//文本标签类：具体同事类
class Label extends Component {
	public void update() {
		System.out.println("文本标签内容改变，客户信息总数加1。");
	}
}

//新增具体中介者类
class SubConcreteMediator extends ConcreteMediator {
	//增加对Label对象的引用
	public Label label;
	
	public void componentChanged(Component c) {
	    //单击按钮
if(c == addButton) {
			System.out.println("--单击增加按钮--");
			list.update();
			cb.update();
			userNameTextBox.update();
			label.update(); //文本标签更新
		}
        //从列表框选择客户
		else if(c == list) {
			System.out.println("--从列表框选择客户--");
			cb.select();
			userNameTextBox.setText();
		}
        //从组合框选择客户
		else if(c == cb) {
			System.out.println("--从组合框选择客户--");
			cb.select();
			userNameTextBox.setText();
		}
	}
}

修改客户端测试代码：
class Client {
	public static void main(String args[]) {
        //用新增具体中介者定义中介者对象
		SubConcreteMediator mediator;
		mediator = new SubConcreteMediator();
		
		Button addBT = new Button();
		List list = new List();
	    ComboBox cb = new ComboBox();
	    TextBox userNameTB = new TextBox();
	    Label label = new Label();

		addBT.setMediator(mediator);
		list.setMediator(mediator);
		cb.setMediator(mediator);
		userNameTB.setMediator(mediator);
		label.setMediator(mediator);
		
		mediator.addButton = addBT;
		mediator.list = list;
		mediator.cb = cb;
		mediator.userNameTextBox = userNameTB;
		mediator.label = label;
			
		addBT.changed();
		System.out.println("-----------------------------");
		list.changed();
	}
}

由于在本实例中不同的组件类（即不同的同事类）所拥有的方法并不完全相同，因此中介者类没有针对抽象同事类编程，
导致在具体中介者类中需要维持对具体同事类的引用，客户端代码无法完全透明地对待所有同事类和中介者类。在某些情况下，如果设计得当，
可以在客户端透明地对同事类和中介者类编程，这样系统将具有更好的灵活性和可扩展性。


中介者模式总结
中介者模式将一个网状的系统结构变成一个以中介者对象为中心的星形结构，在这个星型结构中，使用中介者对象与其他对象的一对多关系来取代原有对象之间的多对多关系。
中介者模式在事件驱动类软件中应用较为广泛，特别是基于GUI（Graphical User Interface，图形用户界面）的应用软件，此外，
在类与类之间存在错综复杂的关联关系的系统中，中介者模式都能得到较好的应用。

作用：
协调多个对象之间的关系

主要优点
中介者模式的主要优点如下：
(1)中介者模式简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护和扩展，
   将原本难以理解的网状结构转换成相对简单的星型结构。
(2)中介者模式可将各同事对象解耦。中介者有利于各同事之间的松耦合，我们可以独立的改变和复用每一个同事和中介者，增加新的中介者和新的同事类都比较方便，
   更好地符合“开闭原则”。
(3)可以减少子类生成，中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使各个同事类可被重用，
   无须对同事类进行扩展。

主要缺点
中介者模式的主要缺点如下：
在具体中介者类中包含了大量同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。

适用场景
在以下情况下可以考虑使用中介者模式：
(1)系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。
(2)一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。
(3)想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，
   如果需要改变行为则可以增加新的具体中介者类。

